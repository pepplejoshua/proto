
template<typename T>
class Slice {
private:
    T* start;
    uint length;
    uint arr_capacity;

public:
    Slice(T* s, uint len, uint cap) : start(s), length(len), arr_capacity(cap) {}

    constexpr uint len() const noexcept {
        return length;
    }

    T& operator[](uint index) {
        return *(start + index);
    }

    const T& operator[](uint index) const {
        return start + index;
    }

    Option<T> get(uint index) {
        if (index > length-1) {
            return Option<T>();
        }

        return Option<T>(this[index]);
    }

    Slice<T> make_slice(uint start, uint end_exclusive) {
        return Slice<T>(this->begin() + start, end_exclusive-start, len());
    }

    Slice<T> make_slice_from(uint start) {
        return Slice<T>(this->begin() + start, len()-start, len());
    }

    // Begin and end methods for range-based for loops
    T* begin() noexcept { return start; }
    T* end() noexcept { return start + length; }
    const T* begin() const noexcept { return start; }
    const T* end() const noexcept { return start + length; }
};


template<typename T, uint N>
class Array {
private:
    T data[N] = {};

public:
    Array(std::initializer_list<T> init) {
        std::copy(init.begin(), init.end(), data);
    }

    T& operator[](std::size_t index) {
        return data[index];
    }

    const T& operator[](uint index) const {
        return data[index];
    }

    Option<T> get(uint index) {
        if (index > N-1) {
            return Option<T>();
        }

        return Option<T>(data[index]);
    }

    Slice<T> make_slice(uint start, uint end_exclusive) {
        return Slice<T>(this->begin() + start, end_exclusive-start, len());
    }

    Slice<T> make_slice_from(uint start) {
        return Slice<T>(this->begin() + start, len()-start, len());
    }

    constexpr uint len() const noexcept {
        return N;
    }

    // Begin and end methods for range-based for loops
    T* begin() noexcept { return data; }
    T* end() noexcept { return data + N; }
    const T* begin() const noexcept { return data; }
    const T* end() const noexcept { return data + N; }
};
