
template<typename T>
class Slice {
private:
    T* start;
    // const T* const_start;
    pruint length;
    pruint arr_capacity;

public:
    Slice(T* s, pruint len, pruint cap) : start(s), length(len), arr_capacity(cap) {}

    constexpr pruint len() const noexcept {
        return length;
    }

    T& operator[](pruint index) {
        return start[index];
    }

    const T& operator[](pruint index) const {
        return start[index];
    }

    Option<T> get(pruint index) {
        if (index >= length) {
            return Option<T>();
        }

        return Option<T>(this[index]);
    }

    const Option<T> get(pruint index) const {
        if (index >= length) {
            return Option<T>();
        }

        return Option<T>(this[index]);
    }

    inline Slice<T> make_slice(pruint start, pruint end_exclusive) {
        if (start >= length || end_exclusive > length || start >= end_exclusive) {
            panic(__LINE__, __FILE__, "Invalid slice bounds");
        }
        return Slice<T>(this->start + start, end_exclusive - start, arr_capacity);
    }

    inline const Slice<T> make_slice(pruint start, pruint end_exclusive) const {
        if (start >= length || end_exclusive > length || start >= end_exclusive) {
            panic(__LINE__, __FILE__, "Invalid slice bounds");
        }
        return Slice<T>(this->start + start, end_exclusive - start, arr_capacity);
    }

    inline Slice<T> make_slice_from(pruint start) {
        if (start >= length) {
            panic(__LINE__, __FILE__, "Invalid slice bounds");
        }
        return Slice<T>(this->start + start, length - start, arr_capacity);
    }

    inline const Slice<T> make_slice_from(pruint start) const {
        if (start >= length) {
            panic(__LINE__, __FILE__, "Invalid slice bounds");
        }
        return Slice<T>(this->start + start, length - start, arr_capacity);
    }

    // Begin and end methods for range-based for loops
    inline T* begin() noexcept { return start; }
    inline T* end() noexcept { return start + length; }
    inline const T* begin() const noexcept { return start; }
    inline const T* end() const noexcept { return start + length; }
};

template<typename T, pruint N>
class Array {
private:
    T data[N] = {};

public:
    Array(std::initializer_list<T> init) {
        std::copy(init.begin(), init.end(), data);
    }

    T& operator[](std::size_t index) {
        return data[index];
    }

    const T& operator[](pruint index) const {
        return data[index];
    }

    Option<T> get(pruint index) {
        if (index >= N) {
            return Option<T>();
        }

        return Option<T>(data[index]);
    }

    const Option<T> get(pruint index) const {
        if (index >= N) {
            return Option<T>();
        }

        return Option<T>(this[index]);
    }

    inline Slice<T> make_slice(pruint start, pruint end_exclusive) {
        if (start >= N || end_exclusive > N || start >= end_exclusive) {
            panic(__LINE__, __FILE__, "Invalid slice bounds");
        }
        return Slice<T>(data + start, end_exclusive - start, len());
    }

    inline const Slice<T> make_slice(pruint start, pruint end_exclusive) const {
        if (start >= N || end_exclusive > N || start >= end_exclusive) {
            panic(__LINE__, __FILE__, "Invalid slice bounds");
        }
        // HACK:
        // when you make a slice of a constant array, we make a copy of the array;
        // std::copy(data, data + len(), start_copy);
        // OR UNSAFE HACK:
        // grab data and unsafe cast it to a T*. this is Sparta!
        T* start_copy = (T*)data;
        return Slice<T>(start_copy + start, end_exclusive - start, len());
    }

    inline Slice<T> make_slice_from(pruint start) {
        if (start >= N) {
            panic(__LINE__, __FILE__, "Invalid slice bounds");
        }
        return Slice<T>(data + start, len() - start, len());
    }

    inline const Slice<T> make_slice_from(pruint start) const {
        if (start >= N) {
            panic(__LINE__, __FILE__, "Invalid slice bounds");
        }
        // HACK:
        // when you make a slice of a constant array, we make a copy of the array;
        // std::copy(data, data + len(), start_copy);
        // OR UNSAFE HACK:
        // grab data and unsafe cast it to a T*. this is Sparta!
        T* start_copy = (T*)data;
        return Slice<T>(start_copy, len() - start, len());
    }

    inline constexpr pruint len() const noexcept {
        return N;
    }

    // Begin and end methods for range-based for loops
    inline T* begin() noexcept { return data; }
    inline T* end() noexcept { return data + N; }
    inline const T* begin() const noexcept { return data; }
    inline const T* end() const noexcept { return data + N; }
};
